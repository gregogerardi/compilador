#EJEMPLOS ANALISADOR LEXICO 1 #
_lintegerMaxMin := 2147483648_l,
_singleMax := 340282347000000000000000000000000000000. ,
_singleMin := 0.0000000000000000000000000000000000000117549435 ,

Para el analisis lexico, como cte con el primer y ultimo valor dentro del rango para linteger se utilizo el mayor valor permitido por si la cte era negativa (2147483648), como el lexico corrige sobre este valor
se tomo como primer y ultimo del rango. Lo mismo para el punto 2, donde pide primer y ultimo valor fuera de rango se utilizo 2147483649.

#EJEMPLOS ANALISADOR LEXICO 2 #
_lintegerMaxMin := 2147483649_l,
_singleMax := 340282347000000010000000000000000000000. ,
_singleMin := 0.0000000000000000000000000000000000000117549434 ,

Para evaluar el maximo float, por la representacion interna de doubles en java solo se reconocen ctes mayores a
_singleMax := 340282347000000010000000000000000000000. ,
una cte como
_singleMax := 340282347000000000000000000000000000001. ,
es redondeada y no supera el valor maximo.

#EJEMPLOS ANALISADOR LEXICO 3 #
a)
_singleDecimal := 1.1 ,
b)
_singleSinDecimal := 1. ,
c)
_singleExponente := 10.F3,
d)
_singleSinExponente := 2. ,
e)
_singleExpPositivo := 15.F3 ,
f)
_singleExpNegativo := 15.F-3 ,

#EJEMPLOS ANALISADOR LEXICO 4 #
_identificadorCorto ,
_identificadorQueSePasaDeLosLimitesDeCaracteres ,

#EJEMPLOS ANALISADOR LEXICO 5 #
_identificador_con_25 ,

En este caso el compilador reconoce tres identificadores distintos por los "_",  acorde al enunciado en identificadores solo se permiten letras y digitos.

#EJEMPLOS ANALISADOR LEXICO 6 #
_()estoNoAnda ,

#EJEMPLOS ANALISADOR LEXICO 7 #
if,
iff,
IF,
whileifelse,
WHILE,

Para este ejemplo solo reconoce la palabra de la primer linea, las demas dan errores lexicos.

#EJEMPLOS ANALISADOR LEXICO 8 #
#Esto es un comentario#
#Esto
es
un
comentario
de
muchas
lineas#
esto es un comentario que le falta el numeral de apertura #


#EJEMPLOS ANALISADOR LEXICO 9 #
print('ejemplo de cadena'),
'esto es una cadena bien definida'
'esta cadena no anda
por que es multilinea'

#------------------------------------------------------------------------------------------#

#EJEMPLOS ANALISADOR SINTACTICO 1 #
let mut linteger _var1 ,
let mut single _var2 ,
let single _var3 := 3.4F0,
let single _var3 := 3.4,
let linteger _var4 := 3.4F10,


#EJEMPLOS ANALISADOR SINTACTICO 2 #
let mut linteger _var4;_var6   ;*_var7 ,


#EJEMPLOS ANALISADOR SINTACTICO 3 #
print ('salida por pantalla') ,


#EJEMPLOS ANALISADOR SINTACTICO 4 #
if (_varif=34_l)
print('hola mundo'),
end_if,


#EJEMPLOS ANALISADOR SINTACTICO 5 #
if (_varif=34_l)
{
print('hola mundo1'),
print('hola mundo2'),
print('hola mundo3'),
}
end_if,

#EJEMPLOS ANALISADOR SINTACTICO 6 #
if (_varif=34_l)
print('hola mundo'),
else
print('hola mundo else'),
end_if,

#EJEMPLOS ANALISADOR SINTACTICO 7 #
if ( _var / 2_l+ .2 = 34_l + _algo * _algomas)
print('hola mundo'),
else
print('hola mundo else'),
end_if,

#EJEMPLOS ANALISADOR SINTACTICO 8 #
while ( _var <= _count )
_count := _count + 1_l,,

#EJEMPLOS ANALISADOR SINTACTICO 9 #
while ( _var <= _count )
if ( _var / 2_l+ .2 = 34_l + _algo * _algomas)
print('hola mundo'),
else
print('hola mundo else'),
end_if,
,


#EJEMPLOS ANALISADOR SINTACTICO 10 #
let mut linteger _a; _b; *_c; _d; *_e ,
let linteger _x := 5_l ,


#EJEMPLOS ANALISADOR SINTACTICO 11 #
*_a := &_b ,
_a := &_b ,
*_a := _b ,
#the next one should throw a sintactic error about the non-constant value at the right side of the assignment#
let linteger *_a := _b ,


#EJEMPLOS ANALISADOR SINTACTICO 12 #
#no corresponde #

#EJEMPLOS ANALISADOR SINTACTICO 13 #
#no corresponde #

#EJEMPLOS ANALISADOR SINTACTICO 14 #
#no corresponde #

#EJEMPLOS ANALISADOR SINTACTICO 15 #
#no corresponde #

#EJEMPLOS ANALISADOR SINTACTICO 16 #
_a := -32_l * _B + 4.F10 ,

#EJEMPLOS ANALISADOR SINTACTICO 17 #
#no corresponde #

#EJEMPLOS ANALISADOR SINTACTICO 18 #
#no corresponde #

para los float comentar que concideramos el mismo rango tanto para positivos como para negativos
los float deben obligatoriamente si llevan la letra f estar acompañados por un valor numerico
aclarar la separacion de la sentencia if en encabezado y cuerpo para manejar errores sin tantas combinaciones posibles
aclarar que no contemplamos el error de la regla de la sentencia while que no incorpora la palabra while por los conflicots shift reduce que genera contra las reglas de la sentencia if.
signo fin de archivo en excel e informe se usa $ pero en el compilador se utiliza el ascci de ACK porque el $ puede estar incluido en agun comentario
aclarar que si se carga una constante negatiova en la tabla de simbolos tambien existira su version positiva, se deja el chequeo para semantica
sobre la entrada anterior si la entrada negativa es el maximo valor permitido la entrada positiva se elimina de la tabla por que es imposible encontrar otra constante con ese valor positivo


#------------------------------------------------------------------------------------------#

#EJEMPLOS ANALISADOR SEMANTICO Y GENERACION DE TERCETOS#


#PROBANDO LA ASIGNACION DE TIPO A UNA VARIABLE INMUTABLE
EN LA ENTRADA DE LA TABLA DE SIMBOLOS SE VEN LOS TIPOS#
let linteger _a := 20_l,

#PROBANDO LA ASIGNACION DE TIPO A UNA VARIABLE MUTABLE
EN LA ENTRADA DE LA TABLA DE SIMBOLOS SE VEN LOS TIPOS#
let mut linteger _a,

#PROBANDO LA ASIGNACION DE TIPO A VARIAS VARIABLES MUTABLES EN UNA SOLA LINEA
EN LA ENTRADA DE LA TABLA DE SIMBOLOS SE VEN LOS TIPOS#
let mut linteger _a; _b; _c,

#PROBANDO LA ASIGNACION DE TIPO A VARIAS VARIABLES DE DISTINTAS FORMAS
EN LA ENTRADA DE LA TABLA DE SIMBOLOS SE VEN LOS TIPOS#
let mut linteger _a; _b; _c,
let mut linteger _d,
let linteger _e:=22_l,

#PROBANDO LA ASIGNACION DE TIPO A VARIAS VARIABLES DE DISTINTAS FORMAS
Y DISTINTOS TIPOS
EN LA ENTRADA DE LA TABLA DE SIMBOLOS SE VEN LOS TIPOS#
let mut linteger _a; _b; _c,
let mut single _af; _bf; _cf,
let mut linteger _d,
let mut single _df,
let linteger _e:=22_l,
let single _ef:=22.5,


#PROBANDO LA ASIGNACION ENTRE VARIABLES DEL MISMO TIPO MUTABLES
SE CREA EL TERCETO ACORDE#
let mut linteger _a; _b,
_a:=_b,

#PROBANDO LA ASIGNACION ENTRE VARIABLES DE DISTINTO TIPO MUTABLES
SE MUESTRA EL ERROR SEMANTICO#
let mut linteger _a,
let mut single _b,
_a:=_b,

#¡¡¡BUG!!!
COMO LAS CTES SE GUARDAN UTILIZANDO COMO LEXEMA EL VALOR CONVERTIDO A DOUBLE SIN
NINGUN PREFIJO O SUFIJO INDICANDO EL TIPO, UNA CTE INTEGER 20 Y UNA CTE SINGLE 20,0 SE
GUARDAN AMBAS CON LEXEMA 20.0, Y AL INTENTAR UTILIZAR DOS CTES CON EL MISMO VALOR
PERO DISTINTO TIPO INTERPRETA A LA SEGUNDA COMO UNA REFERENCIA A LA PRIMERA EN
LUGAR DE UNA CTE NUEVAMENTE DECLARADA#

let linteger _e:=22_l,
let single _ef:=22.0,

#SOLUCION: AGREGAR UNA EXTENSION A LOS LEXEMAS DIFIRIENDO LOS TIPOS#

#¡¡¡BUG!!!
el caso donde una cte negativa se detecta y su contraparte positiva nunca es utilizada, entonces en
la tabla de simbolos quedan ambas ctes, tanto la negativa como la positiva#

let linteger _e:= -22_l,

#SOLUCION implementar un contador de usos que registre cuando se usa la cte positiva en el lexico y luego en el
sintactico cuando se detecta que una cte era negativa disminuir el contador de usos de la version
positiva de la misma cte, y si este contador luego de la disminucion resulta cero eliminar la cte
positiva porque significa que nadie mas la uso hasta ahora, en caso de usarse mas adelante el lexico
tan solo debera darla de alta de nuevo en la tabla de simbolos#

#PROBANDO LA ASIGNACION ENTRE VARIABLES NO MUTABLES
SE MUESTRA EL ERROR#
let linteger _a:=22_l,
let linteger _b:=22_l,
_a:=_b,

#PROBANDO LA ASIGNACION ENTRE VARIABLES NO MUTABLES Y CTE
SE MUESTRA EL ERROR#
let linteger _a:=22_l,
_a:=22_l,

#PROBANDO LA ASIGNACION ENTRE VARIABLES NO MUTABLES Y DE DISTINTO TIPO
SE MUESTRA EL ERROR POR INCOMPATIBILIDAD DE TIPO, NO SE ALCANZA EL
ERROR POR MUTABILIDAD PORQUE EL DE TIPO SE REVISA PRIMERO#
let linteger _a:=22_l,
let single _af:=22.5,
_a:=_af,

#PROBANDO LA REDECLARACION DE VARIABLES
SE MUESTRA EL ERROR#
let linteger _a:=22_l,
let linteger _a:=22_l,

#PROBANDO LA REDECLARACION DE VARIABLES 2
SE MUESTRA EL ERROR#
let mut linteger _a,let mut linteger _a,

#PROBANDO LA REDECLARACION DE
 VARIABLES 3
SE MUESTRA EL ERROR#
let mut linteger _a; _a,

#PROBANDO LA REDECLARACION DE VARIABLES 4
SE MUESTRA EL ERROR#
let linteger _a:=22_l,
let mut linteger _a,

#PROBANDO LA GENERARION DE TERCETOS PARA ASIGNACIONES
SE VE LA LISTA DE TERCETOS#
let mut linteger _a;_b;_c,
_a:=22_l,
_b:=_a,
_c:=_b,

#PROBANDO LA GENERARION DE TERCETOS PARA ASIGNACIONES CON EXPRESIONES
SE VE LA LISTA DE TERCETOS#
let mut linteger _a;_b;_c,
_a:=22_l+_b*_c,
#PROBANDO LA GENERARION DE TERCETOS PARA ASIGNACIONES CON EXPRESIONES
SE VE LA LISTA DE TERCETOS#
let mut linteger _a;_b;_c,
_a:=22_l+_b*_c,

#PROBANDO LA GENERARION DE TERCETOS PARA ASIGNACIONES CON EXPRESIONES 2
SE VE LA LISTA DE TERCETOS#
let mut single _af;_bf;_cf,
_af:=22.0+_bf*_cf,

#PROBANDO LA GENERARION DE TERCETOS PARA ASIGNACIONES CON EXPRESIONES INCORPORANDO TIPOS INCOMPATIBLES
SE VE EL ERROR SEMANTICO#
#NOTA: IGNORAR LA LISTA DE TERCETOS, ESTA QUEDA MAS CONSTRUIDA PORQUE EN LA REGLA DE LA ASIGNACION UTILIZA EL ULTIMO YYVAL PARA EL LADO DE LA EXPRESION QUE TUVO
ANTES DE GENERAR EL ERROR, QUE FUE EL 22.0, DE HABER SIDO COMPATIBLES LOS TIPOS ESTA ENTRADA DE LA PILA
DE YYVALs SE HABRIA CAMBIADO POR EL TERCETO RESULTANTE DE LA SUMA COMO EN EL EJEMPLO
_a:= 22_l + 2_l,#

let mut linteger _a,
_a:=
22_l + 2.0,

#PROBANDO LA GENERARION DE TERCETOS PARA ASIGNACIONES CON EXPRESIONES INCORPORANDO TIPOS INCOMPATIBLES MAS VARIADO
SE VE EL ERROR SEMANTICO#
#NOTA: IGNORAR LA LISTA DE TERCETOS, MISMO CASO ANTERIOR#

_a:= 22_l + 2_l,#
let mut linteger _a; _c,
let mut single _af; _cf,
_a := 22_l + 2_l * 2.2 / 24_l - _cf,

#PROBANDO VARIABLES NO DECLARADAS LADO IZQUIERDO
SE VE EL ERROR#
#NOTA: EL ERROR POR INCOMPATIBILIDAD DE TIPOS SE DA PORQUE LA VARIABLE NO DECLARADA TIENE COMO TIPO "Deesconocido"
Y NO ES EL MISMO TIPO QUE LA CTE 22_l DE TIPO linteger#
_a:=22_l,

#PROBANDO VARIABLES NO DECLARADAS LADO DERECHO
SE VE EL ERROR#
#NOTA: EL ERROR POR INCOMPATIBILIDAD DE TIPOS SE DA PORQUE LA VARIABLE NO DECLARADA TIENE COMO TIPO "Deesconocido"
Y NO ES EL MISMO TIPO QUE LA CTE 22_l DE TIPO linteger#
let mut linteger _a,
_a:=_b,

#PROBANDO PRINT DE CADENA
SE VE EL TERCETO GENERADO#
print('ejemplo de cadena'),

#PROBANDO PRINT DE CADENA CON TIPO DISTINTO DE CADENA
NO ES NECESARIO CHEQUEO SEMANTICO DADO QUE LA GRAMATICA
SOLO ACEPTA UNA CTE DE TIPO CADENA EN LA SENTENCIA PRINT,
Y ESTE TIPO YA SE CONOCE DESDE EL ANALISIS LEXICO
SE VE EL ERROR SINTACTICO#
print(_a),


#------------------------------------#
#--SECCION CON SENTENCIAS DE CONTROL--#
#------------------------------------#

#PROBANDO SENTENCIA IF CON SALTOS,
SE VEN LOS TERCETOS GENERADOS#

#NOTA: EN EL CASO DE IFS SIN ELSE, SE GENERA UN BI INCESARIO HACIA LA LINEA INMEDIATAMENTE
SIGUIENTE, ESTO SE DA PORQUE LA GENERACION DE ESTE TERCETO DE SALTO INCONDICIONAL SE GENERA EN
UNA MISMA REGLA TANTO PARA EL IF CON ELSE COMO EL IF SIN ELSE#
#POSIBLE OPTIMIZACION: UTILIZAR REGLAS DISTINTAS PARA LOS IF CON Y SIN BLOQUE ELSE,
O UNA VEZ GENERADA LA LISTA DE TERCETOS RECORRERLA E ELIMINAR TODOS LOS SALTOS HACIA LINEAS SIGUIENTES
(DURANTE LA GENERACION DE CODIGO ASSEMBLER POR EJEMPLO)

let mut linteger _a,
if (_a=22_l)
print('hola mundo'),
end_if,
print('next to if'),

#PROBANDO SENTENCIA IF CON BLOQUE THEN Y SALTOS,
SE VEN LOS TERCETOS GENERADOS#

#NOTA: IGUAL QUE ANTERIOR#

let mut linteger _a,
if (_a=34_l)
{
print('hola mundo1'),
print('hola mundo2'),
print('hola mundo3'),
}
end_if,

#PROBANDO SENTENCIA IF CON BLOQUE THEN Y ELSE Y SALTOS,
SE VEN LOS TERCETOS GENERADOS#

let mut linteger _a,
if (_a=22_l)
print('hola mundo'),
else
print('hola mundo else'),
end_if,

#PROBANDO SENTENCIA IF CON BLOQUE THEN Y ELSE, CONDICION COMPLEJA
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _a;_b;_c,
if ( _a / 2_l+ 2_l = 34_l + _c * _b)
print('hola mundo'),
else
print('hola mundo else'),
end_if,

#PROBANDO SENTENCIA IF CON BLOQUE THEN Y BLOQUE ELSE,
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _a,
if (_a=34_l)
{
print('hola mundo1'),
print('hola mundo2'),
print('hola mundo3'),
}
else
{
print('hola mundo else1'),
print('hola mundo else2'),
print('hola mundo else3'),
}
end_if,

#PROBANDO SENTENCIA IF CON CONDICION DE TIPO INCORRECTO
SE VE EL ERROR SEMANTICO GENERADO#
let mut single _b,
if (_b=22.1)
print('hola mundo'),
end_if,
print('next to if'),

#PROBANDO SENTENCIA WHILE CON UNA SENTENCIA SOLA,
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _a,
while ( _a <= 22_l )
_a := _a + 1_l,,

#PROBANDO SENTENCIA WHILE CON UN BLOQUE DE SENTENCIAS,
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _a,
while ( _a <= 22_l )
{
_a := _a + 1_l,
_a := _a + 1_l,
},

#PROBANDO SENTENCIA WHILE CON UN BLOQUE DE SENTENCIAS CON UN IF ANIDADO,
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _a,
while ( _a <= 22_l )
{
    _a := _a + 1_l,
    if (_a=34_l)
    {
        print('hola mundo1'),
        print('hola mundo2'),
        print('hola mundo3'),
    }
    else
    {
        print('hola mundo else1'),
        print('hola mundo else2'),
        print('hola mundo else3'),
    }
    end_if,
},


#------------------------------------#
#--SECCION CON PUNTEROS--#
#------------------------------------#

#PROBANDO DECLARACION DE PUNTEROS
SE VE EL TIPO EN LA TABLA DE SIMBOLOS#
let mut linteger *_a,

#PROBANDO DECLARACION DE PUNTEROS MEZCLADA CON NO PUNTEROS
SE VE EL TIPO EN LA TABLA DE SIMBOLOS#
let mut linteger *_a;_b;*_c,
let mut single *_af;_bf;*_cf,

#PROBANDO ASIGNACION ENTRE PUNTEROS
SE VEN LOS TERCETOS GENERADOS#
let mut linteger *_a;*_b,
_a:=_b,

#PROBANDO ASIGNACION ENTRE PUNTEROS DISTINTO TIPO
SE VE EL ERROR SEMANTICO#
let mut linteger *_a,
let mut single *_b,
_a:=_b,

#PROBANDO ASIGNACION ENTRE PUNTEROS MUTABLE E INMUTABLE
SE VEN LOS TERCETOS GENERADOS#
let mut linteger *_a;_b,
let linteger *_c:=&_b,
_a:=_c,

#PROBANDO ASIGNACION A PUNTERO DE DIRECCION CTE
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _b,
let linteger *_c:=&_b,

#PROBANDO ASIGNACION A PUNTERO DE VARIABLE SIN ANULAR EL DESREFERENCING
IMPLICITO, SE VE EL ERROR DE COMPATIBILIDAD DE TIPOS#
let mut linteger _b,
let linteger *_c:=_b,

#PROBANDO ASIGNACION A PUNTERO INMUTABLE
SE VE EL ERROR SEMANTICO#
let mut linteger _b,
let linteger *_c:=&_b,
_c:=&_b,

#PROBANDO ASIGNACION A LO APUNTADO POR UN PUNTERO AUNQUE EL PUNTERO SEA INMUTABLE
SE VEN LOS TERCETOS GENERADOS#
let mut linteger _b,
let linteger *_c:=&_b,
*_c:=22_l,

#PROBANDO ASIGNACION A LO APUNTADO POR PUNTEROS DE TIPOS INCOMPATIBLE
SE VE EL ERROR#
let mut linteger *_a;_b,
let mut single *_af;_bf,
_a:=&_b,
_af:=&_bf,
*_a:=*_af,

#PROBANDO ASIGNACION A PUNTEROS DE TIPOS INCOMPATIBLE
SE VE EL ERROR#
let mut linteger *_a;_b,
let mut single *_af;_bf,
_a:=&_b,
_af:=&_bf,
_a:=_af,

#PROBANDO ASIGNACION A PUNTERO DE UNA EXPRESION ARITMETICA DE PUNTEROS
SE VE EL ERROR#
let mut linteger *_a;_b,
let mut single *_af;_bf,
_a:=&_b,
_af:=&_bf,
_a:=_a+_a-&_b,

#¡¡¡BUG!!!
el caso donde se intenta acceder a un puntero que nunca fue inicializado, da un null pointer
 exception al tratar de preguntar por el tipo de la variable apuntada, y esta ser null
 el caso siguiente lo ejemplifica, notar la inicializacion comentada#

let mut linteger _integerMutable1; *_punteroALinteger,
#_punteroALinteger := &_integerMutable1,#
*_punteroALinteger :=_integerMutable1+1_l,

#SOLUCION controlar siempre antes de acceder a puntero que halla sido inicializado,
dar una inicializacion por defecto apuntando a una variable de tipo "Sin Inicializar",
usar una variable por defecto que no sea de ningun otro tipo asegura que se de un error por
tipos incompatibles en un acceso a un puntero que no apunta a nada. solo se chequea
la redeclaracion o no declaracion de las variables, no sus inicializaciones, a los enteros
y singles les daremos valores por defecto o les dejaremos conservar la basura que halla en memoria
en la cuarta etapa#
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
----------------------------------------------------------------------------------
----------------------------------------------------------------------------------
__________________________________________________________________________________
__________________________________________________________________________________


#EJEMPLO DE PROGRAMA COMPLETO QUE USA TODOS
LOS RECURSOS#

let linteger _integerInmutable := 10_l,
let mut linteger _integerMutable1; *_punteroALinteger; _integerMutable2,
let single _singleInmutable := 10.5,
let mut single _singleMutable1; _singleMutable2,
_integerMutable1 := 1_l,
_integerMutable2 := _integerMutable1,
_singleMutable1 := 1.5,
_singleMutable2 := _singleInmutable,
#los singles no se usaran en el bucle, estan solo
como ejemplo del uso de asignaciones a singles#
_punteroALinteger := &_integerMutable1,
print('inicio del while'),
while ( _integerMutable1 < _integerInmutable )
{
    #incremento la variable que controla el
    while accediendola desde el puntero#
    *_punteroALinteger :=_integerMutable1+1_l,
    _integerMutable2:=_integerMutable1,
    print('inicio del if'),
    if ( _integerMutable1 +  _integerMutable2 <= _integerInmutable)
    {
        print('hola mundo'),
        print('dentro del if'),
        print('porque los enteros juntos suman menos o igual a 10'),
    }
    else
    {
        print('chau mundo cruel'),
        print('dentro del else'),
        print('porque los enteros juntos suman mas de 10'),
    }
  end_if,
  print('fin del if'),
},
print('fin del while'),


---------------------------------------------------------------------
PRUEBAS FERMIN

let linteger _a := 12_l,
let linteger _b := 4_l,
let mut linteger _c,

_c := _a + _b,
if (_c = 16_l){
print ('suma enteros bien echa dio 16'),
} end_if,

_c := _a - _b,
if (_c = 8_l){
print (' resta enteros bien echa dio 8'),
} end_if,

let mut linteger _a,
let mut linteger _c,
let mut linteger _b,
_a := 15_l,
_b := 3_l,
_c := _a / _b,
if (_c =5_l){
print('Anduvo'),
print('Anduvo'),
print('Anduvo'),
}
else
{
print('No Anduvo'),
print('No Anduvo'),
print('No Anduvo'),
}
end_if,
print('hola'),


#invoke printf, cfm$("%d\n"), _c#
let linteger _integerInmutable := 10_l,
let mut linteger _integerMutable1; *_punteroALinteger; *_punteroLoco; _integerMutable2,

_integerMutable1 := 15_l,
_integerMutable2 := 15_l,
_punteroALinteger := &_integerMutable1,
_punteroLoco := &_integerMutable2,

if(_punteroALinteger = &_integerMutable1){
print('hola'),
}
end_if,
print('asdsad'),